# 0.1+0.2 ==0.3 返回false



1. 在JS中能否表示的数字的绝对值范围是5e-324 ~ 1.7976931348623157e+308，这一点可以通过Number.MAX_VALUE和Number.MIN_VALUE来得到证实
2. 在JS中能够表示的最大安全整数的范围是：-9007199254740991 ~ 9007199254740991，这一点可以通过Number.MIN_SAFE_INTEGER和Number.MAX_SAFE_INTEGER来求证

https://juejin.im/post/5a6fce10f265da3e261c3c71


js的Number采用的时IEEE 754 64位双精度浮点数编码，而浮点数表示方式具有以下特点：

### IEEE 754 Floating-point　　　　　　　　　　　　　　　　　　

  众所周知JS仅有Number这个数值类型，而Number采用的时IEEE 754 64位双精度浮点数编码。而浮点数表示方式具有以下特点：

  1. 浮点数可表示的值范围比同等位数的整数表示方式的值范围要大得多；

  2. 浮点数无法精确表示其值范围内的所有数值，而有符号和无符号整数则是精确表示其值范围内的每个数值；

  3. 浮点数只能精确表示m*2e的数值；

  4. 当biased-exponent为2e-1-1时，浮点数能精确表示该范围内的各整数值；

  5. 当biased-exponent不为2e-1-1时，浮点数不能精确表示该范围内的各整数值。

  由于部分数值无法精确表示（存储），于是在运算统计后偏差会愈见明显。


## Why 0.1 + 0.2 === 0.30000000000000004 ?　

    在浮点数运算中产生误差值的示例中，最出名应该是0.1 + 0.2 === 0.30000000000000004了，到底有多有名？看看这个网站就知道了http://0.30000000000000004.com/。也就是说不仅是JavaScript会产生这种问题，只要是采用IEEE 754 Floating-point的浮点数编码方式来表示浮点数时，则会产生这类问题。下面我们来分析整个运算过程。

  1. 0.1 的二进制表示为 1.1001100110011001100110011001100110011001100110011001 1(0011)+ * 2^-4；

  2. 当64bit的存储空间无法存储完整的无限循环小数，而IEEE 754 Floating-point采用round to nearest, tie to even的舍入模式，因此0.1实际存储时的位模式是0-01111111011-1001100110011001100110011001100110011001100110011010；

  3. 0.2 的二进制表示为 1.1001100110011001100110011001100110011001100110011001 1(0011)+ * 2^-3；

  4. 当64bit的存储空间无法存储完整的无限循环小数，而IEEE 754 Floating-point采用round to nearest, tie to even的舍入模式，因此0.2实际存储时的位模式是0-01111111100-1001100110011001100110011001100110011001100110011010；

  5. 实际存储的位模式作为操作数进行浮点数加法，得到 0-01111111101-0011001100110011001100110011001100110011001100110100。转换为十进制即为0.30000000000000004。